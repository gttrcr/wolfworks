using System.Net;
using System.Net.Sockets;
using System.Text;
using System.Diagnostics;

namespace NetWolf
{
    public class WolframLink
    {
        private readonly int port = 1642;
        private readonly Mutex wolfMutex;
        private readonly Socket mathKernel;
        private static Process? wlserver;
        public List<Input> DefinedFunctions { get; private set; }

        public WolframLink(string ip = "")
        {
            if (ip == "")
                ip = Dns.GetHostByName(Dns.GetHostName()).AddressList.ToList().Where(x => x.AddressFamily == AddressFamily.InterNetwork).ToList().First().ToString();

            wolfMutex = new Mutex();
            DefinedFunctions = new List<Input>();

            if (wlserver == null)
            {
                File.WriteAllText(Py.Name, Py.Code);
                Run(Py.Name);
            }

            IPHostEntry ipHostInfo = Dns.GetHostEntry(Dns.GetHostName());
            IPAddress ipAddress = IPAddress.Parse(ip);
            IPEndPoint remoteEP = new IPEndPoint(ipAddress, port);
            mathKernel = new Socket(ipAddress.AddressFamily, SocketType.Stream, ProtocolType.Tcp);
            mathKernel.Connect(remoteEP);
        }

        ~WolframLink()
        {
            wolfMutex.ReleaseMutex();
            mathKernel.Disconnect(true);
            mathKernel.Close();
            mathKernel.Dispose();
            wlserver?.Kill();
            wlserver?.Close();
            wlserver?.Dispose();
        }

        private void Run(string cmd, string args = "")
        {
            ProcessStartInfo start = new ProcessStartInfo();
            start.FileName = @"python";
            start.Arguments = string.Format("{0} {1}", cmd, args);
            start.UseShellExecute = false;// Do not use OS shell
            start.CreateNoWindow = true; // We don't need new window
            start.RedirectStandardOutput = true;// Any output, generated by application will be redirected back
            start.RedirectStandardError = true; // Any error in standard output will be redirected back (for example exceptions)
            wlserver = Process.Start(start);
            StreamReader reader = wlserver.StandardOutput;
            Thread.Sleep(2000);
            new Thread(() =>
            {
                string stderr = wlserver.StandardError.ReadToEnd();
                wlserver.Kill();
                wlserver.Close();
                wlserver.Dispose();
                throw new Exception(stderr);
            }).Start();
        }

        //The only function that contains Compute function
        public Result Execute(Transferable input)
        {
            wolfMutex.WaitOne();

            byte[] byteData = Encoding.ASCII.GetBytes(input.Text);
            if (mathKernel.Send(byteData) != byteData.Length)
                throw new Exception();
            byte[] rec = new byte[1000];
            int length = mathKernel.Receive(rec);
            string response = Encoding.ASCII.GetString(rec, 0, length);

            wolfMutex.ReleaseMutex();

            return new Result(this, response);
        }

        public Result Execute(string input)
        {
            return Execute(new Input(this, input));
        }

        public List<Result> Execute(List<Transferable> input)
        {
            return input.Select(x => Execute(x)).ToList();
        }

        public List<Result> Execute(List<string> input)
        {
            return input.Select(x => Execute(new Input(this, x))).ToList();
        }

        public void SetFunction(Transferable input)
        {
            if (!DefinedFunctions.Contains(input))
                DefinedFunctions.Add((Input)input);
            Execute(input);
        }

        public void SetFunction(string input)
        {
            SetFunction(new Input(this, input));
        }

        public Result CallFunction(Transferable input, List<Transferable> arguments, string name = "")
        {
            string inputStr = (name == "" ? name : name + "=") + input.Text + "[" + string.Join(",", arguments.Select(x => x.Text)) + "]";
            return Execute(inputStr);
        }

        public Result CallFunction(string input, List<string> arguments, string name = "")
        {
            return CallFunction(new Input(this, input), arguments.Select(x => new Input(this, x)).Cast<Transferable>().ToList(), name);
        }

        public Result Simplify(Transferable? input = null, string name = "")
        {
            input ??= new Input(this, "%");
            string inputStr = (name == "" ? name : name + "=") + "Simplify[" + input.Text + "]";
            return Execute(inputStr);
        }

        public Result Length(Transferable? input = null, string name = "")
        {
            input ??= new Input(this, "%");
            string inputStr = (name == "" ? name : name + "=") + "Length[" + input.Text + "]";
            return Execute(inputStr);
        }

        public Result Part(Transferable? input = null, int index = 1, string name = "")
        {
            input ??= new Input(this, "%");
            string inputStr = (name == "" ? name : name + "=") + input.Text + "[[" + index + "]]";
            return Execute(inputStr);
        }

        public Result NumberQ(Transferable? input = null, string name = "")
        {
            input ??= new Input(this, "%");
            string inputStr = (name == "" ? name : name + "=") + "NumberQ[" + input.Text + "]";
            return Execute(inputStr);
        }

        public Result ArrayQ(Transferable? input = null, string name = "")
        {
            input ??= new Input(this, "%");
            string inputStr = (name == "" ? name : name + "=") + "ArrayQ[" + input.Text + "]";
            return Execute(inputStr);
        }

        public Result MatrixQ(Transferable? input = null, string name = "")
        {
            input ??= new Input(this, "%");
            string inputStr = (name == "" ? name : name + "=") + "MatrixQ[" + input.Text + "]";
            return Execute(inputStr);
        }

        public Result PolynomialQ(Transferable? input = null, string name = "")
        {
            input ??= new Input(this, "%");
            string inputStr = (name == "" ? name : name + "=") + "PolynomialQ[" + input.Text + "]";
            return Execute(inputStr);
        }

        public Result Abs(Transferable? input = null, string name = "")
        {
            input ??= new Input(this, "%");
            string inputStr = (name == "" ? name : name + "=") + "Abs[" + input.Text + "]";
            return Execute(inputStr);
        }

        public Result Flatten(Transferable? input = null, int index = 0, string name = "")
        {
            input ??= new Input(this, "%");
            string inputStr = (name == "" ? name : name + "=") + "Flatten[" + input + ", " + index + "]";
            return Execute(inputStr);
        }

        public Result Flatten(string input = "%", int index = 0, string name = "")
        {
            string inputStr = (name == "" ? name : name + "=") + "Flatten[" + input + ", " + index + "]";
            return Execute(inputStr);
        }

        public Result Export(string path, string obj = "%", string name = "")
        {
            string inputStr = (name == "" ? name : name + "=") + "Export[\"" + path + "\", " + obj + "]";
            return Execute(inputStr);
        }

        public Result Graph(WolframObj.GraphObj gr)
        {
            string vertices = "";
            if (gr.Vertices != null)
                vertices = string.Join(',', gr.Vertices);

            string edges = "";
            if (gr.Edges != null)
                edges = string.Join(',', gr.Edges);

            string edgeWeight = "";
            if (gr.EdgeWeight != null)
                edgeWeight = string.Join(',', gr.EdgeWeight);

            string options = "";
            if (gr.Options != null)
                options = string.Join(',', gr.Options);

            string inputStr = gr.Name + "=" + "Graph[{" + vertices + "}" + (edges == "" ? edges : ", {" + edges + "}") + (options == "" ? options : ", " + options) + "]";
            return Execute(inputStr);
        }

        //Add here more driver methods

        public void Dispose()
        {
            mathKernel.Dispose();
        }

        #region DEPRECATED

        /*
        public List<string> RecursiveSimplify(string input)
        {
            string pattern = @"Abs\[([^\[\]A]+|(?<Level>\[)|(?<-Level>\]))+(?(Level)(?!))\]";
            MatchCollection matchList = Regex.Matches(input, pattern);
            List<string> list = matchList.Cast<Match>().Select(match => match.Value).Distinct().ToList();
            List<string> binary = Enumerable.Range(0, (int)Math.Pow(2, list.Count)).Select(x => ToBinary(x, list.Count)).ToList();

            List<string> output = Execute(ReplaceAbs(input, list, binary)).Select(x => x.Text).ToList();
            for (int i = 0; i < output.Count; i++)
            {
                if (output[i].Contains("Abs["))
                {
                    string tmp = output[i];
                    output.RemoveAt(i);
                    output.AddRange(RecursiveSimplify(tmp));
                    i = -1;
                }
            }

            return output;
        }

        private List<string> ReplaceAbs(string input, List<string> abs, List<string> positive)
        {
            List<string> ret = new List<string>();
            List<string> args = abs.Select(x => x.Substring(4, x.Length - 5)).ToList();
            for (int i = 0; i < positive.Count; i++)
            {
                string retEl = input;
                string pos = positive[i];
                for (int p = 0; p < pos.Length; p++)
                {
                    string argsSign = "";
                    if (pos[p] == '1')
                        argsSign = args[p];
                    else if (args[p][0] == 's')
                        argsSign = "-" + string.Concat(args[p].Select(c => c == '-' ? '+' : c == '+' ? '-' : c));
                    else
                        argsSign = string.Concat(args[p].Select(c => c == '-' ? '+' : c == '+' ? '-' : c));

                    retEl = retEl.Replace(abs[p], "(" + argsSign + ")");
                }

                ret.Add(retEl);
            }

            return ret;
        }

        private string ToBinary(int x, int size = 32)
        {
            char[] buff = new char[size];

            for (int i = size - 1; i >= 0; i--)
            {
                int mask = 1 << i;
                buff[size - 1 - i] = (x & mask) != 0 ? '1' : '0';
            }

            return new string(buff);
        }
        */

        #endregion DEPRECATED
    }
}